use java.net.URL
use java.io.File
use java.net.InetAddress

use java.lang.StringBuilder

use java.util.HashMap
use java.util.Iterator

use java.util.regex.Pattern
use java.util.regex.Matcher

use ::src/ExePackerCore.bbj::ExePackerCore
use ::src/StateHandler.bbj::StateHandler
use ::src/parser/JnlpFileParser.bbj::JnlpFileParser
use ::src/AdminBaseHandler.bbj::AdminBaseHandler
use ::src/AdminAPIConnectionWindow.bbj::AdminAPIConnectionWindow
use ::src/ConnectionSettingsWindow.bbj::ConnectionSettingsWindow
use ::src/ConfigFileHandler.bbj::ConfigFileHandler

use ::src/Logger.bbj::Logger

use ::src/configuration/BuildSettings.bbj::BuildSettings
use ::src/configuration/BuildSettingsIF.bbj::BuildSettingsIF

use ::src/configuration/OSSpecificSettings.bbj::OSSpecificSettings
use ::src/configuration/PackageBuildSettings.bbj::PackageBuildSettings

class public ExePacker

    field private BBjSysGui sysGui!
    field private BBjButton btnBrowse!
    field private BBjButton btnCancel!
    field private BBjButton btnGenerate!
    field private BBjButton btnJreBrowse!
    field private BBjButton btnRefreshConfigurations!

    field private BBjTopLevelWindow window!
    field private BBjTopLevelWindow fileChooserWindow!

    field private BBjFileChooser fileChooser!

    field private BBjInputE inpeJreDirectory!
    field private BBjInputE inpeOutputDirectory!

    field private BBjListEdit leServerHostName!
    field private BBjListEdit leJnlpConfiguration!
    field private BBjProgressBar pgbGenerateProgress!

    rem the checkboxes on the lower part of the window
    field private BBjCheckBox chbEmulateWebstart!
    field private BBjCheckBox cbClearOutputDirectory!
    field private BBjCheckBox chbAutomaticallySetUserID!

    rem the checkboxes used to select the target platforms 
    field private BBjCheckBox cbGenerateMacClientPackage!
    field private BBjCheckBox cbGenerateLinuxClientPackage!
    field private BBjCheckBox cbGenerateWindowsClientPackage!

    rem the input fields with the target jdk paths
    field private BBjInputE inpeMacOpenJDKPath!
    field private BBjInputE inpeLinuxOpenJDKPath!
    field private BBjInputE inpeWindowsOpenJDKPath!

    rem the menu buttons used to select the jdk directory or archive files to use
    field private BBjMenuButton mbBrowseMacOpenJDKPath!
    field private BBjMenuButton mbBrowseLinuxOpenJDKPath!
    field private BBjMenuButton mbBrowseWindowsOpenJDKPath!

    rem the labels for the target platform jdk input fields
    field private BBjStaticText txtMacOpenJDKPath!
    field private BBjStaticText txtLinuxOpenJDKPath!
    field private BBjStaticText txtWindowsOpenJDKPath!

    rem the list of jnlp applications 
    field private BBjVector jnlpApplications!

    field private HashMap adminBaseMap!
    field private BBjAdminBase defaultAdminBase!

    field private StateHandler stateHandler!
    field private JnlpFileParser jnlpFileParser!
    field private AdminBaseHandler adminBaseHandler!

    field private String CLOSE_APPLICATION_EVENT! = "closeExePackerEvent"

    field private ExePackerCore exePacker!

    field private String currentHostname!

    field private Logger logger!
    field private ConfigFileHandler configHandler!

    field private BBjMenu mnSettings!
    field private BBjMenuItem miConnectionSettings!

    method public ExePacker()
        #sysGui! = BBjAPI().openSysGui("X0")

        rem the JnlpExePacker/cfg/config.properties file handler 
        #configHandler! = ConfigFileHandler.getInstance()

        rem the custom logger 
        #logger! = Logger.getInstance()

        #exePacker! = new ExePackerCore()

        rem either returns a valid object or throws an exception
        #defaultAdminBase! = #getAdminBase("localhost")

        #adminBaseMap!= new HashMap()
        if #defaultAdminBase! <> null() then
            #adminBaseMap!.put("localhost", #defaultAdminBase!)
        endif

        rem used to keep track of the selected values 
        rem in order to pre-set them in a later launch
        #stateHandler!     = new StateHandler()

        rem used to parse the jnlp xml files 
        #jnlpFileParser!   = new JnlpFileParser()

        rem used to retrieve the server infos using the AdminAPI
        #adminBaseHandler! = new AdminBaseHandler()

        #initGui()
    methodend

    method public BBjAdminBase getAdminBase(String server!)
        #logger!.trace("ExePacker::getAdminBase(String)")

        rem First try using the default credentials
        username! = "admin"
        password! = "admin123"

        declare AdminAPIConnectionWindow win!
        win! = new AdminAPIConnectionWindow()

        declare BBjAdminBase adminBase!
        declare InetAddress address!

        address! = InetAddress.getByName(server!, err=*next)
        if address! = null() then
            throw "Failed to connect to the specified server: " + server! + $0A$ + "Provide a valid server name/IP", 300
            methodret null()
        endif

        rem reading the Admin API connection settings from the properties file 
        port    = #configHandler!.getAdminApiPort()
        timeout = #configHandler!.getAdminApiTimeout()
        useSSL! = #configHandler!.useSSLForAdminApiConnection()

        counter = 0
        validCredentials! = Boolean.FALSE
        while(adminBase! = null() AND counter < 5)
            #logger!.debug("------------------------------------------------------------")
            #logger!.debug("Connection to the BBjAdminAPI using the following entries: ")
            #logger!.debug("Server Address : " + address!.getHostAddress().toString())
            #logger!.debug("Server Hostname: " + address!.getHostName().toString())
            #logger!.debug("Port:            " + str(port))
            #logger!.debug("Timeout:         " + str(timeout))
            #logger!.debug("Use SSL:         " + str(useSSL!))
            #logger!.debug("Username:        " + username!)
            #logger!.debug("------------------------------------------------------------")

            adminBase! = BBjAdminFactory.getBBjAdmin(address!, port, useSSL!, timeout, username!, password!, err=*next)

            rem exiting the loop once we get a valid BBjAdminBase object
            if(adminBase! <> null()) then
                break
            endif

            errorMessage! = errmes(-1)
            #logger!.error("Failed to connect to the BBj Admin API: " + errorMessage!)
            answer = msgbox("Failed to connect to the Admin API. The following error was thrown: " + $0A$ + errorMessage!)
            answer = msgbox("Would you like to retry by specifying the connection parameters ?", 4)

            if answer <> 6 then
                break
            endif

            rem pre-setting the window values
            win!.setHostname(server!)
            win!.setPort(port)
            win!.setTimeout(timeout)
            win!.setUseSSL(useSSL!)
            win!.setUsername(username!)
            win!.setPassword(password!)

            win!.show()

            useSSL!   = win!.useSSL()
            username! = win!.getUsername()
            password! = win!.getPassword()
            address!  = InetAddress.getByName(win!.getHostname())

            port      = win!.getPort()
            timeout   = win!.getTimeout()

            counter = counter + 1
        wend

        if(counter = 5) then
            #logger!.error("The connection to the BBjAdminAPI failed five times")
            rem #logger!.error("The application is now terminating")

            message$ = "The connection to the BBjAdminAPI failed five times in a row." + $0A$
            message$ = message$ + "The application is now terminating"
            a = msgbox(message$)

            methodret null()
        endif

        methodret adminBase!
    methodend

    method private void initGui()
        #logger!.trace("ExePacker::initGui()")

        print 'cs'
        print 'hide'

        handle = #sysGui!.resOpen("src/ui/ExePacker.arc")
        #window! = #sysGui!.createTopLevelWindow(handle, 101)

        #leServerHostName! = cast(BBjListEdit, #window!.getControl("leServerHost"))
        #leServerHostName!.addItem("localhost")
        #leServerHostName!.setEditable(1)
        #leServerHostName!.selectIndex(0)
        #leServerHostName!.setCallback(BBjAPI.ON_LIST_SELECT, #this!, "serverHostNameListSelect")

        #leJnlpConfiguration! = cast(BBjListEdit, #window!.getControl("leJnlpApplication"))

        #btnRefreshConfigurations! = cast(BBjButton, #window!.getControl("btnRefreshJnlpApplicationList"))
        #btnRefreshConfigurations!.setCallback(BBjAPI.ON_BUTTON_PUSH, #this!, "refreshConfigurationsButtonPush")

        rem The labels
        #txtMacOpenJDKPath!     = cast(BBjStaticText, #window!.getControl("txtMacOpenJDKPath"))
        #txtLinuxOpenJDKPath!   = cast(BBjStaticText, #window!.getControl("txtLinuxOpenJDKPath"))
        #txtWindowsOpenJDKPath! = cast(BBjStaticText, #window!.getControl("txtWindowsOpenJDKPath"))

        rem the JDK directory / archive inputE controls
        #inpeMacOpenJDKPath!     = cast(BBjInputE, #window!.getControl("inpeMacOpenJDKPath"))
        #inpeLinuxOpenJDKPath!   = cast(BBjInputE, #window!.getControl("inpeLinuxOpenJDKPath"))
        #inpeWindowsOpenJDKPath! = cast(BBjInputE, #window!.getControl("inpeWindowsOpenJDKPath"))

        rem The Menu Buttons used to select the JDK directory / archive paths
        #mbBrowseMacOpenJDKPath!     = cast(BBjMenuButton, #window!.getControl("mbBrowseMacOpenJDKPath"))
        #mbBrowseLinuxOpenJDKPath!   = cast(BBjMenuButton, #window!.getControl("mbBrowseLinuxOpenJDKPath"))
        #mbBrowseWindowsOpenJDKPath! = cast(BBjMenuButton, #window!.getControl("mbBrowseWindowsOpenJDKPath"))

        rem The checkbox controls used to determine wether to generate client packages for a specific OS or not
        #cbGenerateMacClientPackage!     = cast(BBjCheckBox, #window!.getControl("cbGenerateMacClientPackage"))
        #cbGenerateLinuxClientPackage!   = cast(BBjCheckBox, #window!.getControl("cbGenerateLinuxClientPackage"))
        #cbGenerateWindowsClientPackage! = cast(BBjCheckBox, #window!.getControl("cbGenerateWindowsClientPackage"))

        #mnSettings! = cast(BBjMenu, #window!.getMenu("Menu-101"))
        #miConnectionSettings! = cast(BBjMenuItem, #mnSettings!.getMenuItem(102))
        #miConnectionSettings!.setCallback(BBjAPI.ON_MENU_ITEM_SELECT, #this!, "connectionSettingsMenuItemSelected")

        javaHome! = System.getProperty("java.home", err=*next)

        osName! = System.getProperty("os.name")
        osName! = cvs(osName!, 11)

        if osName!.startsWith(ExePackerCore.TARGET_PLATFORM_LINUX()) then
            #cbGenerateLinuxClientPackage!.setSelected(Boolean.TRUE)
            #enableLinuxOpenJDKSelectionControls(Boolean.TRUE)
            #inpeLinuxOpenJDKPath!.setText(javaHome!)
        endif

        if osName!.startsWith(ExePackerCore.TARGET_PLATFORM_WINDOWS()) then
            #cbGenerateWindowsClientPackage!.setSelected(Boolean.TRUE)
            #enableWindowsOpenJDKSelectionControls(Boolean.TRUE)
            #inpeWindowsOpenJDKPath!.setText(javaHome!)
        endif

        if osName!.startsWith(ExePackerCore.TARGET_PLATFORM_MAC()) then
            #cbGenerateMacClientPackage!.setSelected(Boolean.TRUE)
            #enableMacOpenJDKSelectionControls(Boolean.TRUE)
            #inpeMacOpenJDKPath!.setText(javaHome!)
        endif

        #cbGenerateMacClientPackage!     .setCallback(BBjAPI.ON_CHECK_ON, #this!, "cbGenerateMacClientPackageChecked")
        #cbGenerateLinuxClientPackage!   .setCallback(BBjAPI.ON_CHECK_ON, #this!, "cbGenerateLinuxClientPackageChecked")
        #cbGenerateWindowsClientPackage! .setCallback(BBjAPI.ON_CHECK_ON, #this!, "cbGenerateWindowsClientPackageChecked")

        #cbGenerateMacClientPackage!     .setCallback(BBjAPI.ON_CHECK_OFF, #this!, "cbGenerateMacClientPackageUnchecked")
        #cbGenerateLinuxClientPackage!   .setCallback(BBjAPI.ON_CHECK_OFF, #this!, "cbGenerateLinuxClientPackageUnchecked")
        #cbGenerateWindowsClientPackage! .setCallback(BBjAPI.ON_CHECK_OFF, #this!, "cbGenerateWindowsClientPackageUnchecked")

        #mbBrowseMacOpenJDKPath!     .setCallback(BBjAPI.ON_BUTTON_PUSH, #this!, "mbBrowseOpenJDKPath")
        #mbBrowseLinuxOpenJDKPath!   .setCallback(BBjAPI.ON_BUTTON_PUSH, #this!, "mbBrowseOpenJDKPath")
        #mbBrowseWindowsOpenJDKPath! .setCallback(BBjAPI.ON_BUTTON_PUSH, #this!, "mbBrowseOpenJDKPath")

        #inpeOutputDirectory! = cast(BBjInputE, #window!.getControl("inpeOutputDirectory"))

        outputDir! = #stateHandler!.getLastUsedOutputDirectory()
        if(outputDir! <> null()) then
            declare File outputDirectory!
            outputDirectory! = new File(outputDir!)
            if(outputDirectory!.exists() AND outputDirectory!.isDirectory()) then
                #inpeOutputDirectory!.setText(outputDir!)
            endif
        endif

        #btnBrowse! = cast(BBjButton, #window!.getControl("btnBrowseOutputDirectory"))
        #btnBrowse!.setCallback(BBjAPI.ON_BUTTON_PUSH, #this!, "browseButtonPush")

        #cbClearOutputDirectory! = cast(BBjCheckBox, #window!.getControl("cbClearOutputDirectory"))
        #cbClearOutputDirectory!.setSelected(1)

        #chbEmulateWebstart! = cast(BBjCheckBox, #window!.getControl("chbEmulateWebstart"))
        #chbEmulateWebstart!.setToolTipText("This option causes the program to behave as if it was launched via Webstart: Causes the info(3,6) to return 3. This option automatically starts the Thin Client Proxy Server" )
        #chbEmulateWebstart!.setSelected(Boolean.TRUE)

        #chbAutomaticallySetUserID! = #window!.getCheckBox("chbAutomaticallySetUserID")
        #chbAutomaticallySetUserID!.setSelected(Boolean.TRUE)

        #pgbGenerateProgress! = cast(BBjProgressBar, #window!.getControl("pgbStatusGeneration"))
        #pgbGenerateProgress!.setVisible(0)
        #pgbGenerateProgress!.setIndeterminate(1)

        #btnGenerate! = cast(BBjButton, #window!.getControl("btnGenerate"))
        #btnGenerate!.setCallback(BBjAPI.ON_BUTTON_PUSH, #this!, "generateButtonPush")

        #btnCancel! = cast(BBjButton, #window!.getControl("btnCancel"))
        #btnCancel!.setCallback(BBjAPI.ON_BUTTON_PUSH, #this!, "cancelButtonPush")

        #window!.setCallback(BBjAPI.ON_CLOSE, #this!, "closeWindow")

        declare auto BBjMenuItem item!
        declare auto BBjPopupMenu popup!

        popup! = #mbBrowseLinuxOpenJDKPath!.getDropdownMenu()
        popup!.getMenuItem(101).setCallback(BBjAPI.ON_POPUP_ITEM_SELECT, #this!, "browseLinuxOpenJDKDirectoryPath")
        popup!.getMenuItem(102).setCallback(BBjAPI.ON_POPUP_ITEM_SELECT, #this!, "browseLinuxOpenJDKArchivePath")

        popup! = #mbBrowseWindowsOpenJDKPath!.getDropdownMenu()
        popup!.getMenuItem(101).setCallback(BBjAPI.ON_POPUP_ITEM_SELECT, #this!, "browseWindowsOpenJDKDirectoryPath")
        popup!.getMenuItem(102).setCallback(BBjAPI.ON_POPUP_ITEM_SELECT, #this!, "browseWindowsOpenJDKArchivePath")

        popup! = #mbBrowseMacOpenJDKPath!.getDropdownMenu()
        popup!.getMenuItem(101).setCallback(BBjAPI.ON_POPUP_ITEM_SELECT, #this!, "browseMacOpenJDKDirectoryPath")
        popup!.getMenuItem(102).setCallback(BBjAPI.ON_POPUP_ITEM_SELECT, #this!, "browseMacOpenJDKArchivePath")

        #serverChanged(#leServerHostName!,0)

        #window!.setVisible(0)
    methodend

    method public void connectionSettingsMenuItemSelected(BBjMenuItemSelectEvent menuItemSelected!)
        declare ConnectionSettingsWindow settingsWindow!
        settingsWindow! = new ConnectionSettingsWindow()
        settingsWindow!.show()

        rem TODO: after changing the settings check if something needs to be reloaded 
    methodend

    method private void enableMacOpenJDKSelectionControls(Boolean enabled!)
        #txtMacOpenJDKPath!.setEnabled(enabled!)
        #inpeMacOpenJDKPath!.setEnabled(enabled!)
        #mbBrowseMacOpenJDKPath!.setEnabled(enabled!)
    methodend

    method private void enableLinuxOpenJDKSelectionControls(Boolean enabled!)
        #txtLinuxOpenJDKPath!.setEnabled(enabled!)
        #inpeLinuxOpenJDKPath!.setEnabled(enabled!)
        #mbBrowseLinuxOpenJDKPath!.setEnabled(enabled!)
    methodend

    method private void enableWindowsOpenJDKSelectionControls(Boolean enabled!)
        #txtWindowsOpenJDKPath!.setEnabled(enabled!)
        #inpeWindowsOpenJDKPath!.setEnabled(enabled!)
        #mbBrowseWindowsOpenJDKPath!.setEnabled(enabled!)
    methodend

    method public void cbGenerateMacClientPackageChecked(BBjCheckOnEvent event!)
        #enableMacOpenJDKSelectionControls(Boolean.TRUE)
    methodend

    method public void cbGenerateLinuxClientPackageChecked(BBjCheckOnEvent event!)
        #enableLinuxOpenJDKSelectionControls(Boolean.TRUE)
    methodend

    method public void mbBrowseOpenJDKPath(BBjButtonPushEvent event!)
        control! = event!.getControl()

        switch control!.getID()
            case #mbBrowseMacOpenJDKPath!.getID()     ; targetOS! = ExePackerCore.TARGET_PLATFORM_MAC()     ; break
            case #mbBrowseLinuxOpenJDKPath!.getID()   ; targetOS! = ExePackerCore.TARGET_PLATFORM_LINUX()   ; break
            case #mbBrowseWindowsOpenJDKPath!.getID() ; targetOS! = ExePackerCore.TARGET_PLATFORM_WINDOWS() ; break

            rem the default can never be the case since 
            rem the callback was only registered on the three menu buttons
            case default; break
        swend

        #browseForOpenJDKPath(Boolean.FALSE, targetOS!)
    methodend

    method public void browseLinuxOpenJDKArchivePath(BBjPopupSelectEvent event!)
        #browseForOpenJDKPath(Boolean.FALSE, ExePackerCore.TARGET_PLATFORM_LINUX())
    methodend

    method public void browseLinuxOpenJDKDirectoryPath(BBjPopupSelectEvent event!)
        #browseForOpenJDKPath(Boolean.TRUE, ExePackerCore.TARGET_PLATFORM_LINUX())
    methodend

    method public void browseWindowsOpenJDKArchivePath(BBjPopupSelectEvent event!)
        #browseForOpenJDKPath(Boolean.FALSE, ExePackerCore.TARGET_PLATFORM_WINDOWS())
    methodend

    method public void browseWindowsOpenJDKDirectoryPath(BBjPopupSelectEvent event!)
        #browseForOpenJDKPath(Boolean.TRUE, ExePackerCore.TARGET_PLATFORM_WINDOWS())
    methodend

    method public void browseMacOpenJDKArchivePath(BBjPopupSelectEvent event!)
        #browseForOpenJDKPath(Boolean.FALSE, ExePackerCore.TARGET_PLATFORM_MAC())
    methodend

    method public void browseMacOpenJDKDirectoryPath(BBjPopupSelectEvent event!)
        #browseForOpenJDKPath(Boolean.TRUE, ExePackerCore.TARGET_PLATFORM_MAC())
    methodend

    method public void browseForOpenJDKPath(Boolean directory!, String targetOS!)
        if #fileChooserWindow! <> null() AND !#fileChooserWindow!.isDestroyed() then
            #fileChooserClose(null())
        endif

        #fileChooserWindow! = #sysGui!.addWindow(1000, 100, 100, 500, 400, "FileChooser")
        #fileChooserWindow!.setCallback(BBjAPI.ON_CLOSE, #this!, "fileChooserClose")

        if directory! then
            #fileChooser! = #fileChooserWindow!.addFileChooser(1001, 10, 10, 480, 380, "", $000C$)
        else
            #fileChooser! = #fileChooserWindow!.addFileChooser(1001, 10, 10, 480, 380, "", $0004$)

            #fileChooser!.setAcceptAllFileFilterUsed(0)
            if targetOS! = ExePackerCore.TARGET_PLATFORM_WINDOWS() then
                #fileChooser!.addFileFilter("*.zip", "*.zip")
            else
                #fileChooser!.addFileFilter("*.tar.gz", "*.tar.gz")
            endif
        endif

        rem setting the target OS name in the namespace for the callback method to collect it 
        rem alternatively, a class member variable could have been used 
        BBjAPI().getGroupNamespace().setValue("exe-packer-filechooser-target-os", targetOS!)

        #fileChooser!.setCallback(BBjAPI.ON_FILECHOOSER_APPROVE, #this!, "fileChooserApprove")
        #fileChooser!.setCallback(BBjAPI.ON_FILECHOOSER_CANCEL, #this!, "fileChooserCancel")
    methodend

    method public void fileChooserClose(BBjCloseEvent event!)
        #fileChooserWindow!.destroy()
    methodend

    method public void fileChooserApprove(BBjFileChooserApproveEvent event!)
        targetOS! = BBjAPI().getGroupNamespace().getValue("exe-packer-filechooser-target-os")
        BBjAPI().getGroupNamespace().removeValue("exe-packer-filechooser-target-os")

        file! = event!.getFileChooser().getSelectedFile()

        if targetOS! = ExePackerCore.TARGET_PLATFORM_WINDOWS() then
            #inpeWindowsOpenJDKPath!.setText(file!)
        else
            if targetOS! = ExePackerCore.TARGET_PLATFORM_LINUX() then
                #inpeLinuxOpenJDKPath!.setText(file!)
            else
                #inpeMacOpenJDKPath!.setText(file!)
            endif
        endif

        #fileChooserClose(null())
    methodend

    method public void fileChooserCancel(BBjFileChooserCancelEvent event!)
        #fileChooserClose(null())
    methodend

    method public void cbGenerateWindowsClientPackageChecked(BBjCheckOnEvent event!)
        #enableWindowsOpenJDKSelectionControls(Boolean.TRUE)
    methodend

    method public void cbGenerateWindowsClientPackageUnchecked(BBjCheckOffEvent event!)
        #enableWindowsOpenJDKSelectionControls(Boolean.FALSE)
    methodend

    method public void cbGenerateLinuxClientPackageUnchecked(BBjCheckOffEvent event!)
        #enableLinuxOpenJDKSelectionControls(Boolean.FALSE)
    methodend

    method public void cbGenerateMacClientPackageUnchecked(BBjCheckOffEvent event!)
        #enableMacOpenJDKSelectionControls(Boolean.FALSE)
    methodend

    method public void refreshConfigurationsButtonPush(BBjButtonPushEvent event!)
        if #currentHostname! <> #leServerHostName!.getText() then
            index = #leServerHostName!.getSelectedIndex()
            if !#serverChanged(#leServerHostName!,index) then
                methodret
            endif
        endif

        #refreshJnlpApplicationList()
    methodend

    method public void serverHostNameLostFocus(BBjLostFocusEvent event!)
        listEdit! = cast(BBjListEdit, event!.getControl())
        index = listEdit!.getSelectedIndex()

        #serverChanged(listEdit!,index)
    methodend

    rem /**
    rem  * 
    rem  * @return true if a connection was established to the given server, false otherwise.
    rem  */
    method private Boolean serverChanged(BBjListEdit listEdit!, BBjNumber index)
        #enableControls(0)

        if(index < 0) then
            hostname! = listEdit!.getText()

            seterr adminBaseRetrieveHandler
                adminBase! = #getAdminBase(hostname!)
            adminBaseRetrieveHandler:
                if(adminBase! = null()) then
                    a = msgbox(errmes(-1))
                    #enableControls(1)
                    listEdit!.focus()
                    #leJnlpConfiguration!.removeAllItems()
                    methodret Boolean.FALSE
                endif

            #adminBaseMap!.put(hostname!, adminBase!)
            listEdit!.addItem(hostname!)
            listEdit!.selectIndex(listEdit!.getItemCount()-1)
        endif

        #enableControls(1)

        adminBase! = #adminBaseMap!.getOrDefault(listEdit!.getText(), #defaultAdminBase!)
        #adminBaseHandler!.setAdminBase(adminBase!)
        #currentHostname! = str(listEdit!.getText())

        declare BBjAdminList list!
        #jnlpApplications! = #adminBaseHandler!.getJnlpApplications()

        #leJnlpConfiguration!.removeAllItems()
        it! = #jnlpApplications!.iterator()
        while(it!.hasNext())
            #leJnlpConfiguration!.addItem(it!.next().getString(BBjAdminJnlpApplication.NAME))
        wend

        #leJnlpConfiguration!.selectIndex(0)

        methodret Boolean.TRUE
    methodend

    method public void serverHostNameListSelect(BBjListSelectEvent event!)
        listEdit! = cast(BBjListEdit, event!.getControl())
        index = listEdit!.getSelectedIndex()

        #serverChanged(listEdit!,index)
    methodend

    method private void refreshJnlpApplicationList()
        #leJnlpConfiguration!.removeAllItems()

        declare BBjAdminList list!
        #jnlpApplications! = #adminBaseHandler!.getJnlpApplications()

        declare HashMap nameMap!
        nameMap! = new HashMap()

        declare BBjAdminJnlpApplication app!

        currentIndex = 0
        it! = #jnlpApplications!.iterator()
        while(it!.hasNext())
            app! = cast(BBjAdminJnlpApplication, it!.next())
            appName! = app!.getString(BBjAdminJnlpApplication.NAME)

            #leJnlpConfiguration!.addItem(appName!)
            nameMap!.put(appName!, currentIndex)
            currentIndex = currentIndex +1
        wend

        index = 0
        lastApplicationName! = #stateHandler!.getLastUsedJnlpApplicationName()
        if(lastApplicationName! <> null()) then
            index = cast(BBjNumber, nameMap!.getOrDefault(lastApplicationName!, 0))
        endif

        #leJnlpConfiguration!.selectIndex(index)
    methodend

    rem Returns the PackageBuildSettings object with the information entered by the user
    method private PackageBuildSettings getPackageBuildSettings()
        declare PackageBuildSettings settings!
        settings! = new PackageBuildSettings()

        settings!.enableEmulateWebstartOption(#chbEmulateWebstart!.isSelected())
        settings!.enableClearOutputDirectoryOption(#cbClearOutputDirectory!.isSelected())

        rem Get the output directory file handle
        declare File outputDir!
        outputDir! = new File(#inpeOutputDirectory!.getText())

        rem check for the output directory's existence
        if(!outputDir!.exists()) then
            a = msgbox("The specified output directory doesn't exist. Would you like to create it ?", 4)

            if(a <> 6) then
                a = msgbox("Select an existing output directory in order to generate the .exe file.")
                goto getBuildSettingsFailed
            endif

            outputDir!.mkdirs()
        endif

        rem making sure that the output directory is indeed a directory
        if(!outputDir!.isDirectory()) then
            a = msgbox("You need to specify a valid output directory to generate an .exe file.")
            goto getBuildSettingsFailed
        endif

        settings!.setOutputDirectory(outputDir!)

        settings!.enableAutomaticallySetUserIDOption(#chbAutomaticallySetUserID!.isSelected())

        declare OSSpecificSettings osSettings!

        if #cbGenerateWindowsClientPackage!.isSelected() then
            osSettings! = new OSSpecificSettings()
            osSettings!.setTargetOSName(ExePackerCore.TARGET_PLATFORM_WINDOWS())

            jreDirectory! = new File(#inpeWindowsOpenJDKPath!.getText())
            if jreDirectory!.exists() then
                if jreDirectory!.isDirectory() then
                    osSettings!.setJreSourceDirectory(jreDirectory!)
                else
                    if jreDirectory!.isFile() AND jreDirectory!.getName().endsWith(".zip") then
                        osSettings!.setJreSourceArchiveFile(jreDirectory!)
                    endif
                endif

                settings!.addOSSpecificSettings(osSettings!)
            endif
        endif

        if #cbGenerateLinuxClientPackage!.isSelected() then
            osSettings! = new OSSpecificSettings()
            osSettings!.setTargetOSName(ExePackerCore.TARGET_PLATFORM_LINUX())

            jreDirectory! = new File(#inpeLinuxOpenJDKPath!.getText())
            if jreDirectory!.exists() then
                if jreDirectory!.isDirectory() then
                    osSettings!.setJreSourceDirectory(jreDirectory!)
                else
                    if jreDirectory!.isFile() AND jreDirectory!.getName().endsWith(".tar.gz") then
                        osSettings!.setJreSourceArchiveFile(jreDirectory!)
                    endif
                endif

                settings!.addOSSpecificSettings(osSettings!)
            endif
        endif

        if #cbGenerateMacClientPackage!.isSelected() then
            osSettings! = new OSSpecificSettings()
            osSettings!.setTargetOSName(ExePackerCore.TARGET_PLATFORM_MAC())

            jreDirectory! = new File(#inpeMacOpenJDKPath!.getText())
            if jreDirectory!.exists() then
                if jreDirectory!.isDirectory() then
                    osSettings!.setJreSourceDirectory(jreDirectory!)
                else
                    if jreDirectory!.isFile() AND jreDirectory!.getName().endsWith(".tar.gz") then
                        osSettings!.setJreSourceArchiveFile(jreDirectory!)
                    endif
                endif

                settings!.addOSSpecificSettings(osSettings!)
            endif
        endif

        methodret settings!

        getBuildSettingsFailed:
            #pgbGenerateProgress!.setVisible(0)
            #pgbGenerateProgress!.setText("")
            methodret null()
    methodend

    method public void generateButtonPush(BBjButtonPushEvent event!)
        if #adminBaseMap!.isEmpty() then
            #logger!.error("Attempting to generate client package(s) without valid BBjServices Connection")
            a = msgbox("To generate a client package, you first need to successfully connect to the BBjServcices using the Admin API")
            methodret
        endif

        #logger!.trace("ExePacker::generateButtonPush(BBjButtonPushEvent)")
        #logger!.info("Generating the client packages")

        declare PackageBuildSettings settings!
        settings! = #getPackageBuildSettings()

        declare BBjAdminBase adminBase!

        adminBase! = cast(BBjAdminBase,#adminBaseMap!.getOrDefault(#leServerHostName!.getText(), null()))

        if adminBase! = null() then
            #logger!.error("Failed to generate client package(s): Failed to connect to the BBjServices of the selected Server: " + #leServerHostName!.getText())
            a = msgbox("To generate a client package, you first need to successfull establish a connection to the selected server using the Admin API")
            methodret
        endif

        #adminBaseHandler!.setAdminBase(adminBase!)

        #pgbGenerateProgress!.setVisible(1)
        #pgbGenerateProgress!.setText("Generating the client packages")

        rem #stateHandler!.setLastUsedOutputDirectory(buildSettings!.getOutputDirectory().getAbsolutePath())
        rem #stateHandler!.setLastUsedServerName(#adminBaseHandler!.getHostName())
        rem #stateHandler!.setLastUsedJnlpApplicationName(app!.getString(BBjAdminJnlpApplication.NAME))

        declare BBjAdminJnlpApplication app!
        app! = cast(BBjAdminJnlpApplication, #jnlpApplications!.get(#leJnlpConfiguration!.getSelectedIndex()))

        codeBase! = #getCodebase(#adminBaseHandler!, app!.getString(BBjAdminJnlpApplication.XML))

        #logger!.info("Using codebase: " + codeBase!)

        settings!.setBaseURL(codebase!)

        declare OSSpecificSettings osSetting!
        declare BBjVector osSettings!
        osSettings! = settings!.getOSSpecificSettings()

        #jnlpFileParser!.setPackageBuildSettings(settings!)
        #jnlpFileParser!.setJnlpApplication(app!, #adminBaseHandler!.getCodebaseHostname())

        rem getting the complemented build settings from the parser
        settings! = cast(PackageBuildSettings, #jnlpFileParser!.getPackageBuildSettings())

        if settings!.getOutputDirectory().listFiles().length > 0 AND #cbClearOutputDirectory!.isSelected() then
            a = msgbox("Do you really want to clear the following output directory: " + $0A$ + settings!.getOutputDirectory().getAbsolutePath(), 4, "Confirm Directory Clearing")
            if a = 6 then
                #exePacker!.cleanOutputDirectory(settings!)
            else
                a = msgbox("Do you want to proceed with the package generation ?", 4, "Proceed Package Generation")
                if a <> 6  then
                    a = msgbox("Package generation aborted", 0, "Aborted")
                     #resetProgressBar(null())
                    methodret
                endif
                settings!.enableClearOutputDirectoryOption(Boolean.FALSE)
            endif
        endif

        rem generating the clients
        #exePacker!.generateClientPackages(settings!)

        rem resetting the progressbar
        #pgbGenerateProgress!.setText("Finished")
        BBjAPI().createTimer("",2,#this!, "resetProgressBar")
    methodend

    method public String getCodebase(AdminBaseHandler handler!, String jnlpFileContent!)
        rem get the default values and replace them with the jnlp value if the settings requires it 

        if #configHandler!.useJnlpFileCodeBaseElement() then
            jnlpCodebaseURL! = #jnlpFileParser!.getCodebase(jnlpFileContent!)
            jnlpCodebaseURL! = jnlpCodebaseURL!.trim()

            jnlpCodebasePort!     = null()
            jnlpCodebaseScheme!   = null()
            jnlpCodebaseHostname! = null()

            rem by default the jnlp file looks like this: {-scheme-}://{-hostname-}:{-portnumber-}{-path-}
            rem if the user specifically set a codebase, the value in the jnlp contains an actual URL
            rem The jnlp codebase can only be used if it contains an actual URL
            if jnlpCodebaseURL!.startsWith("http") then

                declare Pattern pattern!
                declare Matcher matcher!

                pattern! = Pattern.compile("^(http[s]?):\/\/([\d\-\.\w]+):(\d+)\/.*")
                matcher! = pattern!.matcher(jnlpCodebaseURL!)

                if matcher!.find() and matcher!.groupCount() = 3 then
                    jnlpCodebaseScheme!   = matcher!.group(1)
                    jnlpCodebaseHostname! = matcher!.group(2)
                    jnlpCodebasePort!     = matcher!.group(3)
                endif
            endif
        endif

        if !handler!.isSSLEnabled() then
            #logger!.info("SSL is not enabled for the selected server")
        else
            webserverSSLPort!    = handler!.getCodebasePort(Boolean.TRUE)
            webserverSSLScheme!  = handler!.getCodebaseScheme(Boolean.TRUE)
        endif

        if !handler!.isSSLEnabled() then
            #logger!.info("HTTP is not enabled for the selected server")
        else
            webserverPort!   = handler!.getCodebasePort(Boolean.FALSE)
            webserverScheme! = handler!.getCodebaseScheme(Boolean.FALSE)
        endif

        webserverHostname! = handler!.getCodebaseHostname()
        secureClientEnabled! = #jnlpFileParser!.isSecureClientEnabled(jnlpFileContent!)

        port!     = #getCodebasePort(jnlpCodebasePort!, webserverSSLPort!, webserverPort!, secureClientEnabled!)
        scheme!   = #getCodebaseScheme(jnlpCodebaseScheme!, webserverSSLScheme!, webserverScheme!, secureClientEnabled!)
        hostname! = #getCodebaseHostname(jnlpCodebaseHostname!, webserverHostname!)

        if port! = null() or scheme! = null() or hostname! = null() then
            methodret null()
        endif

        methodret scheme! + "://" + hostname! + ":" + port! + "/"
    methodend

    method public String getCodebaseHostname(String jnlpCodebaseHostname!, String webserverHostname!)
        if #configHandler!.getDownloadHostnameSetting() = #configHandler!.getFILE_DOWNLOAD_SETTING_JNLP_VALUE() then
            if jnlpCodebaseHostname! <> null() then
                methodret jnlpCodebaseHostname!
            endif

            #logger!.error("Failed to determine the JNLP file's codebase hostname. Falling back to webserver's default")
        endif

        if webserverHostname! <> null()
            methodret webserverHostname!
        endif

        #logger!.error("Failed to determine the webserver's hostname. Aborting")

        methodret null()
    methodend

    method private String getCodebaseScheme(String jnlpCodebaseScheme!, String webserverSSLScheme!, String webserverScheme!, Boolean secureClientEnabled!)
        if #configHandler!.getDownloadSchemeSetting() = #configHandler!.getFILE_DOWNLOAD_SETTING_JNLP_VALUE() then
            if jnlpCodebaseScheme! <> null() then
                methodret jnlpCodebaseScheme!
            endif

            #logger!.error("Failed to determine the JNLP file's codebase scheme. Falling back to webserver default")
        endif

        if secureClientEnabled! then
            if webserverSSLScheme! <> null() then
                methodret webserverSSLScheme!
            endif

            #logger!.error("Failed to determine the webserver's default SSL scheme. Probably SSL is deactivated on the server. Falling back to the HTTP scheme")
        endif

        if webserverScheme! <> null() then
            methodret webserverScheme!
        endif

        #logger!.error("Failed to determine the webserver's default HTTP scheme. Probably HTTP is disabled on the server. Aborting")

        methodret null()
    methodend

    method private String getCodebasePort(String jnlpCodebasePort!, String webserverSSLPort!, String webserverPort!, Boolean secureClientEnabled!)
        if #configHandler!.getDownloadPortSetting() = #configHandler!.getFILE_DOWNLOAD_SETTING_JNLP_VALUE() then
            if jnlpCodebasePort! <> null() then
                methodret jnlpCodebasePort!
            endif

            #logger!.error("Failed to determine the JNLP file's codebase port. Falling back to webserver default")
        endif

        if secureClientEnabled! then
            if webserverSSLPort! <> null() then
                methodret webserverSSLPort!
            endif

            #logger!.error("Failed to determine the webserver's default SSL port. Falling back to the HTTP port default")
        endif

        if webserverPort! <> null() then
            methodret webserverPort!
        endif

        #logger!.error("Failed to determine the webserver's default HTTP port. Aborting")

        methodret null()
    methodend

    method public String getHostNameFromURL(String url!)
        declare Pattern pattern!
        declare Matcher matcher!

        pattern! = Pattern.compile("^(http[s]?):\/\/([\d\-\.\w]+):(\d+)\/.*")
        matcher! = pattern!.matcher(url!)

        if matcher!.find() and matcher!.groupCount() = 3 then
            hostname! = matcher!.group(2)
        endif

        methodret hostname!
    methodend

    method public String getPortFromURL(String url!)
        declare Pattern pattern!
        declare Matcher matcher!

        pattern! = Pattern.compile("^(http[s]?):\/\/([\d\-\.\w]+):(\d+)\/.*")
        matcher! = pattern!.matcher(url!)

        if matcher!.find() and matcher!.groupCount() = 3 then
            port! = matcher!.group(3)
        endif

        methodret port!
    methodend


    method private String getElementFromURL(String url!, BBjNumber group)

    methodend

    rem /**
    rem  * Resets the progressbar after the amount of seconds specified 
    rem  * by the given BBjTimerEvent.
    rem  * 
    rem  * @param event! The BBjTimerEvent which holds the information about the 
    rem  * amount of seconds to wait before resetting the progressbar.
    rem  */
    method public void resetProgressBar(BBjTimerEvent event!)
        if(!#pgbGenerateProgress!.isDestroyed()) then
            #pgbGenerateProgress!.setText("")
            #pgbGenerateProgress!.setValue(0)
            #pgbGenerateProgress!.setVisible(0)
        endif
    methodend

    rem /**
    rem  * The callback method for the Cancel button's button push event.
    rem  * 
    rem  * @param event! The button push event.
    rem  */
    method public void cancelButtonPush(BBjButtonPushEvent event!)
        #closeWindow(null())
    methodend

    rem /**
    rem  * Displays the main window and waits for user input.
    rem  */
    method public void show()
       #window!.setVisible(1)

       BBjAPI().setCustomEventCallback(CLOSE_APPLICATION_EVENT!, "endProgram")

       process_events

       endProgram:
           #window!.destroy()
    methodend

    rem /**
    rem  * Closes the Window.
    rem  */
    method public void closeWindow(BBjCloseEvent event!)
        BBjAPI().postCustomEvent(CLOSE_APPLICATION_EVENT!,"")
    methodend

    rem /**
    rem  * Opens a directory selection dialog for the user to select
    rem  * the exe's output directory.
    rem  */
    method public void browseButtonPush(BBjButtonPushEvent event!)
        path! = #inpeOutputDirectory!.getText()
        fileOpenPath! = dsk("")

        if(path! <> "") then
            declare File directory!
            directory! = new File(path!)

            if(directory!.exists() AND directory!.isDirectory()) then
                fileOpenPath! = directory!.getAbsolutePath()
            endif
        endif

        directoryPath$ = FILEOPEN("Output Directory Selection", fileOpenPath!,"","","",1)
        if(directoryPath$ <> "::CANCEL::") then
            #inpeOutputDirectory!.setText(directoryPath$)
        endif
    methodend

    rem /**
    rem  * Enables/disables the ui controls based on the given boolean value.
    rem  * If the given Boolean value is true, the ui controls are enabled, else they will
    rem  * be disabled.
    rem  * 
    rem  * @param enabled! If true, the ui controls will be enabled, else they will be disabled 
    rem  */
    method public void enableControls(Boolean enabled!)
        #leJnlpConfiguration!.setEnabled(enabled!)

        #inpeOutputDirectory!.setEnabled(enabled!)
        #btnBrowse!.setEnabled(enabled!)
        #cbClearOutputDirectory!.setEnabled(enabled!)

        #chbEmulateWebstart!.setEnabled(enabled!)
        #chbAutomaticallySetUserID!.setEnabled(enabled!)

        #btnGenerate!.setEnabled(enabled!)
    methodend

classend

BBjFileSystem!=BBjAPI().getFileSystem()
fullPath$ = BBjFileSystem!.resolvePath(pgm(-2))

declare File file!
file! = new File(fullPath$)

rem Adding the path to this program into the prefix so that the required programs will be found
prefix """" + file!.getParentFile().getAbsolutePath() + "/"" " + pfx

packer! = new ExePacker()
packer!.show()

release